<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>Let&#39;s write a macro in Rust - Part 2 - hackeryarn</title>
  <meta name="renderer" content="webkit" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>

<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />

<meta name="theme-color" content="#f8f5ec" />
<meta name="msapplication-navbutton-color" content="#f8f5ec">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="#f8f5ec">


<meta name="author" content="" /><meta name="description" content="In the last part we covered the very basics of macros and implemented a single argument query select. This was a good start, but only scratched the surface of what macros can do.
In this part we will implement multi-field select and a basic where calause. That will make our query macro far more useful.
Multi-field select After being able to select one field, the immediate next thing that comes to mind is selecting multiple fields. Just like before, lets start with the invocation syntax:
" /><meta name="keywords" content="blog, tech, ideas" />






<meta name="generator" content="Hugo 0.148.1 with theme even" />


<link rel="canonical" href="https://hackeryarn.com/post/rust-macros-2/" />
<link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
<link rel="manifest" href="/manifest.json">
<link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">



<link href="/sass/main.min.b21c25b30b65a0cc5fa7853ee7d0a14a33817ce15313d5f58fc3a0e8c473d999.css" rel="stylesheet">



<meta property="og:url" content="https://hackeryarn.com/post/rust-macros-2/">
  <meta property="og:site_name" content="hackeryarn">
  <meta property="og:title" content="Let&#39;s write a macro in Rust - Part 2">
  <meta property="og:description" content="In the last part we covered the very basics of macros and implemented a single argument query select. This was a good start, but only scratched the surface of what macros can do.
In this part we will implement multi-field select and a basic where calause. That will make our query macro far more useful.
Multi-field select After being able to select one field, the immediate next thing that comes to mind is selecting multiple fields. Just like before, lets start with the invocation syntax:">
  <meta property="og:locale" content="en">
  <meta property="og:type" content="article">
    <meta property="article:section" content="post">
    <meta property="article:published_time" content="2025-08-24T00:00:00+00:00">
    <meta property="article:modified_time" content="2025-08-24T00:00:00+00:00">

  <meta itemprop="name" content="Let&#39;s write a macro in Rust - Part 2">
  <meta itemprop="description" content="In the last part we covered the very basics of macros and implemented a single argument query select. This was a good start, but only scratched the surface of what macros can do.
In this part we will implement multi-field select and a basic where calause. That will make our query macro far more useful.
Multi-field select After being able to select one field, the immediate next thing that comes to mind is selecting multiple fields. Just like before, lets start with the invocation syntax:">
  <meta itemprop="datePublished" content="2025-08-24T00:00:00+00:00">
  <meta itemprop="dateModified" content="2025-08-24T00:00:00+00:00">
  <meta itemprop="wordCount" content="1251">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Let&#39;s write a macro in Rust - Part 2">
  <meta name="twitter:description" content="In the last part we covered the very basics of macros and implemented a single argument query select. This was a good start, but only scratched the surface of what macros can do.
In this part we will implement multi-field select and a basic where calause. That will make our query macro far more useful.
Multi-field select After being able to select one field, the immediate next thing that comes to mind is selecting multiple fields. Just like before, lets start with the invocation syntax:">

<!--[if lte IE 9]>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js"></script>
<![endif]-->

<!--[if lt IE 9]>
  <script src="https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js"></script>
<![endif]-->

</head>
<body>
  <div id="mobile-navbar" class="mobile-navbar">
  <div class="mobile-header-logo">
    <a href="/" class="logo">hackeryarn</a>
  </div>
  <div class="mobile-navbar-icon">
    <span></span>
    <span></span>
    <span></span>
  </div>
</div>
<nav id="mobile-menu" class="mobile-menu slideout-menu">
  <ul class="mobile-menu-list">
    <a href="/">
        <li class="mobile-menu-item">Home</li>
      </a><a href="/post/">
        <li class="mobile-menu-item">Archives</li>
      </a><a href="/tags/">
        <li class="mobile-menu-item">Tags</li>
      </a><a href="/categories/">
        <li class="mobile-menu-item">Categories</li>
      </a><a href="https://liberapay.com/hackeryarn">
        <li class="mobile-menu-item">Donate</li>
      </a>
  </ul>

  


</nav>

  <div class="container" id="mobile-panel">
    <header id="header" class="header">
        <div class="logo-wrapper">
  <a href="/" class="logo">hackeryarn</a>
</div>





<nav class="site-navbar">
  <ul id="menu" class="menu">
    <li class="menu-item">
        <a class="menu-item-link" href="/">Home</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/post/">Archives</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/tags/">Tags</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="/categories/">Categories</a>
      </li><li class="menu-item">
        <a class="menu-item-link" href="https://liberapay.com/hackeryarn">Donate</a>
      </li>
  </ul>
</nav>

    </header>

    <main id="main" class="main">
      <div class="content-wrapper">
        <div id="content" class="content">
          <article class="post">
    
    <header class="post-header">
      <h1 class="post-title">Let&#39;s write a macro in Rust - Part 2</h1>

      <div class="post-meta">
        <span class="post-time"> 2025-08-24 </span>
        
        
      </div>
    </header>

    <div class="post-toc" id="post-toc">
  <h2 class="post-toc-title">Contents</h2>
  <div class="post-toc-content always-active">
    <nav id="TableOfContents">
  <ul>
    <li><a href="#multi-field-select">Multi-field select</a>
      <ul>
        <li><a href="#matching-multi-field-select">Matching multi-field select</a></li>
        <li><a href="#repetition-match-syntax">Repetition match syntax</a></li>
        <li><a href="#implementing-multi-field-select">Implementing multi-field select</a></li>
        <li><a href="#debugging-macros">Debugging macros</a></li>
      </ul>
    </li>
    <li><a href="#where-clause">Where clause</a>
      <ul>
        <li><a href="#matching-where-clause">Matching where clause</a></li>
        <li><a href="#implementing-where-clause">Implementing where clause</a></li>
      </ul>
    </li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>
  </div>
</div>
    <div class="post-content">
      <p>In the <a href="https://hackeryarn.com/post/rust-macros-1/">last part</a> we covered the very basics of macros and implemented a single argument query select. This was a good start, but only scratched the surface of what macros can do.</p>
<p>In this part we will implement multi-field select and a basic <code>where</code> calause. That will make our query macro far more useful.</p>
<h2 id="multi-field-select">Multi-field select</h2>
<p>After being able to select one field, the immediate next thing that comes to mind is selecting multiple fields. Just like before, lets start with the invocation syntax:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="fm">query!</span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="n">rating</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>Continuing to draw inspiratino from SQL, we use a comma separated list of fields. Using a separator, like a comma, turns out to be idiomatic Rust macro syntax for handling multiple value, so we are in luck with our choice.</p>
<h3 id="matching-multi-field-select">Matching multi-field select</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">  </span><span class="cp">#[macro_export]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">(</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="cp">$db</span>:<span class="nc">ident</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$field</span>:<span class="nc">ident</span><span class="w"> </span><span class="p">),</span><span class="o">+</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>That&rsquo;s quite a bit of new syntax, but it all breaks down to a single new matching construct.</p>
<h3 id="repetition-match-syntax">Repetition match syntax</h3>
<p>The general shape for matching repetition looks like:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">$ ( ... ) sep rep =&gt; {
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">  $ ( ... ) rep
</span></span><span class="line"><span class="cl">  ...
</span></span><span class="line"><span class="cl">}
</span></span></code></pre></td></tr></table>
</div>
</div><p>We need to wrap the repeating match expression in <code>$()</code>, add a separator (a comma in our case), and finish it with a repetition operator. The repetition operator should look familiar as they draw inspiration from regex:</p>
<ul>
<li><code>?</code> for zero or one</li>
<li><code>*</code> for zero or more</li>
<li><code>+</code> for one or more</li>
</ul>
<p>I chose to use <code>+</code> because a blank select makes no sense.</p>
<p>The matcher and expansion connect through the captured variable names, and repeat the same number of times. Everything inside the expansion parentheses (<code>$()</code>) repeats, so we need to be careful about any literals that we put into the expression.</p>
<p>Once we have the repeating match, we can use it in the expression.</p>
<h3 id="implementing-multi-field-select">Implementing multi-field select</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="w">  </span><span class="cp">#[macro_export]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">(</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="cp">$db</span>:<span class="nc">ident</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$field</span>:<span class="nc">ident</span><span class="w"> </span><span class="p">),</span><span class="o">+</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">          </span><span class="cp">$db</span><span class="p">.</span><span class="n">into_iter</span><span class="p">().</span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="cp">$(</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="cp">$field</span><span class="p">,</span><span class="w"> </span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">).</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">      </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>You might be suprprised by the extra set of parentheses around the repetiont usage. This is actually just a plain tuple.</p>
<p>Because we can return mupltiple fields, we have to create some kind of container. Since we can have fields of multiple types, a vector is out of the question. We could lean on <code>serde</code> and require a serializer instance, but that introduces a lot of overhead. A tuple gives us a simple wrapper that&rsquo;s easy to destructure and allows us to handle any number of fields with any mix of types.</p>
<p>And with that, we can execute our query with a multi select:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">results</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">query!</span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="n">rating</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// &gt; [(&#34;Hate Me&#34;, 9), (&#34;Not Like Us&#34;, 10), (&#34;Bad Dreams&#34;, 10), (&#34;Rockin&#39; the Suburbs&#34;, 6), (&#34;Lateralus&#34;, 8), (&#34;Lose Control&#34;, 9), (&#34;Come as you are&#34;, 9)]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>We have to specify the type here, but if you were to use the values later, Rust&rsquo;s compiler can often infer the type.</p>
<h3 id="debugging-macros">Debugging macros</h3>
<p>With the repetition operators the macro gets hard to follow, and it will only get more complicated. This would be the perfect time to look at how we can debug macros.</p>
<p>Rust comes with everything we need built it. To see what marocs expand to, we can run <code>RUSTFLAGS=&quot;-Ztrace_macros&quot; cargo run</code> (note that you will need nightly rust version). This gets pretty noisy, however, since it expands <em>all</em> macros in the entire program. To limit what expands, we can use a macro <code>trace_macros!</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="fm">trace_macros!</span><span class="p">(</span><span class="kc">true</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="kd">let</span><span class="w"> </span><span class="n">results</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="fm">query!</span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="n">rating</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="fm">trace_macros!</span><span class="p">(</span><span class="kc">false</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>This limits the scope to only what we want to analyze and returns the the expected output:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">// = note: expanding `query! { from db select title, rating }`
</span></span><span class="line"><span class="cl">// = note: to `db.into_iter().map(| i | (i.title, i.rating,)).collect()`
</span></span></code></pre></td></tr></table>
</div>
</div><p>The one odd thing about our debug output is the trailing comma in the tuple. Remember how I said that everything in the expansion <code>$()</code> repeats? We had a literal comma inside the repetition expansion so it gets included every time. Tuples and other collections allow trailing commas, but we will see some places, shortly, that do not.</p>
<h2 id="where-clause">Where clause</h2>
<p>So far we only have a <code>select</code> macro which is not much of a query. Let&rsquo;s make our macro more useful:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="fm">query!</span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="n">rating</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">rating</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">artist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Teddy Swims&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>We us <code>=</code> for comparison, and <code>and</code> as a way to support multiple comparisons. Just like with select, we will start by only supporting these two operators and work up to supporting others.</p>
<h3 id="matching-where-clause">Matching where clause</h3>
<p>We actually already have all the tools we need to match this new syntax:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[macro_export]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="cp">$db</span>:<span class="nc">ident</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$field</span>:<span class="nc">ident</span><span class="w"> </span><span class="p">),</span><span class="o">+</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="cp">$($test_field</span>:<span class="nc">ident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$value</span>:<span class="nc">literal</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w"> </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>We will leave our earlier <code>select</code> without <code>where</code> arm as is, and start a new arm that includes <code>where</code>. This should look very familiar although slightly expanded. Our second repetition matcher captures two values (<code>$test_field</code> and <code>$value</code>) and uses a multi character separator (<code>and</code>) before the repetition operator. Both of these demonstrate the power and flexibility of macro matchers.</p>
<p>The only thing we have not seen yet is the use of a new fragment-specifier. The <code>literal</code> specifier lets us use the value exactly as it is. A string will be a string, a number a number, etc.</p>
<h3 id="implementing-where-clause">Implementing where clause</h3>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="cp">#[macro_export]</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="n">macro_rules</span><span class="o">!</span><span class="w"> </span><span class="n">query</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="o">..</span><span class="p">.</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="w"> </span><span class="n">from</span><span class="w"> </span><span class="cp">$db</span>:<span class="nc">ident</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="cp">$(</span><span class="w"> </span><span class="cp">$field</span>:<span class="nc">ident</span><span class="w"> </span><span class="p">),</span><span class="o">+</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="cp">$($test_field</span>:<span class="nc">ident</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="cp">$value</span>:<span class="nc">literal</span><span class="p">)</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="p">)</span><span class="w"> </span><span class="o">=&gt;</span><span class="w"> </span><span class="p">{</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">        </span><span class="cp">$db</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="cp">$(</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="cp">$test_field</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="cp">$value</span><span class="w"> </span><span class="p">)</span><span class="o">&amp;&amp;+</span><span class="w"> </span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">            </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="w"> </span><span class="o">|</span><span class="n">i</span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="cp">$(</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="cp">$field</span><span class="p">,</span><span class="w"> </span><span class="p">)</span><span class="o">+</span><span class="p">)</span><span class="w"> </span><span class="p">).</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">};</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="p">}</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>To do the comparison, we add a call to <code>.filter</code> that will run the comparison based on the field identifier and the literal. This shows that the <code>ident</code> fragment-specifier works for a lot more identifiers than just variables.</p>
<p>One thing to note is that we had to put the <code>&amp;&amp;</code> outside the repetition parentheses. Unlike the tuple syntax, we can&rsquo;t have a dangling <code>&amp;&amp;</code> at the end of our conditional and putting it outside the parentheses will skip adding it to the last item.</p>
<p>With this arm implemented our previous select should continue to work and we can put the new <code>where</code> syntax to work:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="kd">let</span><span class="w"> </span><span class="n">results</span>: <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">String</span><span class="p">,</span><span class="w"> </span><span class="kt">i64</span><span class="p">)</span><span class="o">&gt;</span><span class="w"> </span><span class="o">=</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="fm">query!</span><span class="p">(</span><span class="n">from</span><span class="w"> </span><span class="n">db</span><span class="w"> </span><span class="n">select</span><span class="w"> </span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="n">rating</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">rating</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">artist</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="s">&#34;Teddy Swims&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w"></span><span class="c1">// [(&#34;Bad Dreams&#34;, 10)]
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>As expected, we only get one item. As an additional sanity check, we can expand the macro again with <code>trace_macos!</code>:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-rust" data-lang="rust"><span class="line"><span class="cl"><span class="n">db</span><span class="p">.</span><span class="n">into_iter</span><span class="p">()</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">filter</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">rating</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">artist</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="s">&#34;Teddy Swims&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">.</span><span class="n">map</span><span class="p">(</span><span class="o">|</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">|</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="p">.</span><span class="n">title</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="p">.</span><span class="n">rating</span><span class="p">,)).</span><span class="n">collect</span><span class="p">()</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>And we get the exact result we would expect. Both the condition appear in the <code>filter</code> expression, and they are separated by an <code>&amp;&amp;</code>.</p>
<h2 id="conclusion">Conclusion</h2>
<p>This part expands the macro functionality to far more scenarios. It also covers all the major concepts of declarative macros. With these tools, you should be able to write a wide range of declarative macros.</p>
<p>In the next part we will look at handling multiple operators in our <code>where</code> clause. This will push our tools to their limit and we will need to use one of the most powerful pattern for declarative macros.</p>

    </div>

    
<footer class="post-footer">
      
      <nav class="post-nav">
        
        <a class="next" href="/post/rust-macros-1/">
            <span class="next-text nav-default">Let&#39;s write a macro in Rust - Part 1</span>
            <span class="next-text nav-mobile">Next</span>
            <i class="iconfont icon-right"></i>
          </a>
      </nav>
    </footer>
  </article>
        </div>
        <div id="disqus_thread"></div>
    <script type="text/javascript">
    (function() {
      
      
      if (window.location.hostname === 'localhost') return;

      var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
      var disqus_shortname = 'achernyak';
      dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
      (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

  

  

      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="social-links">
      <a href="https://twitter.com/hackeryarn" class="iconfont icon-twitter" title="twitter"></a>
      <a href="https://www.linkedin.com/in/achernyak" class="iconfont icon-linkedin" title="linkedin"></a>
      <a href="https://github.com/hackeryarn" class="iconfont icon-github" title="github"></a>
  
</div>

<div class="copyright">
  <span class="power-by">
    Powered by <a class="hexo-link" href="https://gohugo.io">Hugo</a>
  </span>
  <span class="division">|</span>
  <span class="theme-info">
    Theme - 
    <a class="theme-link" href="https://github.com/olOwOlo/hugo-theme-even">Even</a>
  </span>

  

  <span class="copyright-year">
    &copy; 
    2018 - 
    2025<span class="heart"><i class="iconfont icon-heart"></i></span><span></span>
  </span>
</div>

    </footer>

    <div class="back-to-top" id="back-to-top">
      <i class="iconfont icon-up"></i>
    </div>
  </div>
  <script type="text/javascript" src="/lib/jquery/jquery-3.2.1.min.js"></script>
  <script type="text/javascript" src="/lib/slideout/slideout-1.0.1.min.js"></script>
  



<script type="text/javascript" src="/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js"></script>








</body>
</html>
