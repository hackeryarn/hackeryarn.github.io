<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Micro on hackeryarn</title>
    <link>https://hackeryarn.com/categories/micro/</link>
    <description>Recent content in Micro on hackeryarn</description>
    <generator>Hugo</generator>
    <language>en</language>
    <lastBuildDate>Wed, 11 Jan 2023 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://hackeryarn.com/categories/micro/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Managing local common lisp projects</title>
      <link>https://hackeryarn.com/post/local-common-lisp-projects/</link>
      <pubDate>Wed, 11 Jan 2023 00:00:00 +0000</pubDate>
      <guid>https://hackeryarn.com/post/local-common-lisp-projects/</guid>
      <description>&lt;p&gt;When I started using lisp, I came from the world of modern dependency managers (npm, pip, maven, and the like). So I started searching for an equivalent in lisp. I quickly came across &lt;code&gt;quicklisp&lt;/code&gt;. To my surprise, however, &lt;code&gt;quicklisp&lt;/code&gt; worked differently than these packages. It works more like a dependency cache than true dependency manager, but that is a topic for another article.&lt;/p&gt;&#xA;&lt;p&gt;The biggest struggle that &lt;code&gt;quicklisp&lt;/code&gt; brought was managing local packages. &lt;code&gt;quicklisp&lt;/code&gt; had no way to reference a dependency at a certain path, and couldn&amp;rsquo;t automatically import the project I was in. This is all for good reason since ASDF (the common lisp build system) allows a lot of freedom.&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
