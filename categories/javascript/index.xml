<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>JavaScript on hackeryarn</title>
    <link>https://hackeryarn.com/categories/javascript/</link>
    <description>Recent content in JavaScript on hackeryarn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sun, 24 Feb 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://hackeryarn.com/categories/javascript/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>The Right Abstraction for Lambdas</title>
      <link>https://hackeryarn.com/post/the-right-abstraction-for-lambdas/</link>
      <pubDate>Sun, 24 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hackeryarn.com/post/the-right-abstraction-for-lambdas/</guid>
      <description>Serverless functions are a great alternative for many light tasks that would traditionally required a server. They allow you to split up work across mutiple small functions, and you only pay for what you use. On top of that, they require less maintenance than managing your own server or Kubernetes cluster.
However, the single function per lambda approach can become too granular. Shared functionality becomes hard to group together. You only have hard to enforce naming convention for lambda that belong together.</description>
    </item>
    
    <item>
      <title>Making Redux Easy</title>
      <link>https://hackeryarn.com/post/making-redux-easy/</link>
      <pubDate>Mon, 11 Feb 2019 00:00:00 +0000</pubDate>
      
      <guid>https://hackeryarn.com/post/making-redux-easy/</guid>
      <description>React and Redux are a top choice for front end projects. React provides fast performance, easy ways to create shared components, and a plethora of libraries. Redux lets you simplify state management in your application, but it has serious drawbacks.
In large projects, Redux bloat your project with repetitive code. To support a single store update, you need to create a reducer that handles an action type which is dispatched from an action called inside a component.</description>
    </item>
    
    <item>
      <title>Universally Testable Dependencies in JavaScript</title>
      <link>https://hackeryarn.com/post/universally-testable-dependencies/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://hackeryarn.com/post/universally-testable-dependencies/</guid>
      <description>JavaScript dependencies are notoriously hard to mock and test across framework and environments. However, Dependency Injection (DI) ensures testability. It is common in statically typed languages, like Java or Go, but is also useful in dynamic languages like JavaScript.
This article will guide you through a simple technique that can apply to any JavaScript code base, frontend or backend, independent of frameworks and libraries.
The technique I am going to demonstrate is arguably not true DI, since the dependencies are still managed by the module using them.</description>
    </item>
    
    <item>
      <title>How Lodash Worked Itself Out of a Job</title>
      <link>https://hackeryarn.com/post/lodash/</link>
      <pubDate>Sun, 25 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://hackeryarn.com/post/lodash/</guid>
      <description>I really loved lodash. It brough the joy of compact functional code to JavaScript. Especially 6 years ago when I first embraced it. It was a wonderful library. Back then, there was no ES6, no Babel, and terrible browser incompatabilities ran rampant. Lodash along with jQuery were the saving light of that time.
I gravitated towards using Lodash because the first language I learned was Scheme. It had functional programing at it&amp;rsquo;s core, and highly influanced how I think about code to this day.</description>
    </item>
    
  </channel>
</rss>